---
title: Single Table Inheritance in Rails
layout: article
categories: articles
---
Single table inheritance (STI) in Rails gets a lot of bad press, much of it deserved. Much of the time it is the wrong way to share code and data among similar models, but it has served me very well in some instances, and I don't think it's wise to forget about it entirely. So, here are some reasons why you might use STI, why you might want to avoid it, and some tips for working with it (if you're sure you want to use it, skip to "the tips":#tips).

For this article I'm assuming you know what STI is and how to set it up in Rails (add a @type@ column and inherit from a parent class). I'm also assuming that you're familiar with "polymorphic associations":http://www.andygoh.net/2008/06/19/ruby-on-rails-polymorphic-association and using modules to share code among different classes. Just because you know how to use these techniques doesn't mean deciding which one to use is easy.


h2. The Choices

Suppose you have three classes in your application which model similar things. To make this easier to think about I'll be referring to some hypothetical classes by name: Car, Truck, and Motorcycle. Let's consider three choices for modeling this situation:

# *Polymorphic Associations* (separate classes, multiple tables)
# *Single Table Inheritance* (separate classes, one table)
# *Single Class* with conditionals (one class, one table)

With Polymorphic Associations you'd use @include@-able modules to share code among classes.

The third choice, Single Class, is not exactly a design pattern, or anything particularly interesting. What I have in mind is an equivalent of the @type@ attribute (maybe called @kind@) and some @if@ statements in the model where you need different behavior for different kinds of objects. OOP purists _hate_ this, but it works well in the real world when there are only a few slight differences between object types and separate classes are overkill.

Here are some questions to ask yourself:

h3. 1. Are the objects, conceptually, children of a single parent?

First and foremost, your design choice needs to be understandable. In the case of a car, a truck, and a motorcycle, it is perfectly reasonable to think of them all as vehicles. If you add a bicycle and a wheelbarrow it may become confusing because, in our minds, these things are not as vehicle-like as a car. This is all to say, don't use single table inheritance just because your classes share some attributes (eg: @num_wheels@, @color@, @length@), make sure there is actually an OO inheritance relationship between each of them and an understandable parent class.


h3. 2. Do you need to do database queries on all objects together?

If you want to list the objects together or run aggregate queries on all of the data, you'll probably want everything in the same database table for speed and simplicity, especially if there is a lot of data. This means choice #2 or #3.


h3. 3. Do the objects have similar data but different behavior?

How many database columns are shared by every model? Are there likely to be many model-specific columns? If so, you may want to consider Polymorphic Associations.

A Car, Truck, and Motorcycle may all have the same attributes, eg:

* @color@
* @engine_size@
* @price@

but different method implementations, eg:

* @drivetrain_weight@                # adds different components
* @value_after_depreciation(years)@  # uses different depreciation rates
* @drivers_license_certifications@   # references different certifications

In this situation STI is probably the right design choice. If there are only minor differences in a few methods, you may want to "cheat" and go with a single class. If the child classes have very different attributes, Polymorphic Associations is probably the way to go.


h2(#tips). STI Tips

If you've ever tried to add STI to an existing Rails application you probably know that many of your @link_to@ and @form_for@ methods throw errors when you add a parent class. This is because ActionPack looks at the class of an object to determine its path and URL, and you haven't mapped routes for your new subclasses. If you want to use one controller for all models you can implement the @model_name@ method in your parent class. I haven't seen any documentation for this method, so this is very unofficial, but it makes sense and it works perfectly for me with Rails 2.3.X. For example:

{% highlight :ruby %}
def self.model_name
  name = "vehicle"
  name.instance_eval do
    def plural;   pluralize;   end
    def singular; singularize; end
  end
  return name
end
{% endhighlight %}

That probably looks confusing, so let me explain:

ActionPack calls @model_name@ on the class of the object passed to a URL-generating method, (eg: @link_to("car", car)@). It expects the return value to implement the @plural@ and @singular@ methods, so we add them to the @"vehicle"@ string using @instance_eval@. The @model_name@ method is then inherited by the @Car@, @Truck@, and @Motorcycle@ subclasses, and ActionPack will see all of these objects as belonging to the parent class (in this case @Vehicle@), and thus use the parent class's named routes (@VehiclesController@). This is all assuming you're using mapped resources. If you're not, please do.

To investigate the @model_name@ invocation yourself, see the Rails source code for the @ActionController::RecordIdentifier#model_name_from_record_or_class@ method. Again: I've never seen this documented, but it does make sense.


{% comment %}

* think about why STI didn't work for susan

* tip: how to make the parent class aware of all subclasses
  * use included hook and the idea in the comment here:
  http://timhward.blogspot.com/2008/06/ror-polymorphic-associations-and.html

* says to use polymorphic_path (doesn't seem to work/make sense):
  http://rookieonrails.blogspot.com/2008/01/sti-views-revisited-or-polymorphic.html
  
  Interestingly enough, this kind of inheritance actually goes against some of OOP's main tennets such as, data decoupling, data encapsulation/hiding, access control and separation of concerns.


* interesting:
  http://stackoverflow.com/questions/555668/single-table-inheritance-and-where-to-use-it-in-rails
  
  Characterising STI as mostly useful when attributes are the same but behaviour differs is "about right", but possibly a little limiting. I like to use STI when there is, as the name suggests, a clear OO-style inheritance relationship, rather than the database-style relationship between objects of different types.
  If there is common code between bots and users, I'd say STI sounds like a winner. If there's just some common attributes, it's probably less applicable but still worth having a go at.


{% endcomment %}
