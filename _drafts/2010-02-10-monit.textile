---
title: "How To Keep Your Daemons Alive"
layout: article
categories: articles
---
As web programmers we're generally pretty comfortable with daemon processes like web and database servers. These programs (eg: Apache and MySQL) have robust and proven methods of keeping themselves alive. Even if they occasionally die they seem to come back to life on their own, and no real knowledge of this mechanism is necessary for their use.

But maybe you're starting to use other daemons like "Memcached":http://memcached.org/ or "Redis":http://code.google.com/p/redis/ which don't come with your operating system in convenient pre-configured packages, or you need a newer version than your package manager provides. What then? Will your daemons be as reliable as the popular server software we're accustomed to? What are the risks?


h2. What Can Go Wrong?

In a live web application? Lots of things. Let's say you're on vacation--these things usually happen when you're on vacation--and you get an email one morning from your hosting provider stating that your machine was "unresponsive" and needed to be rebooted. You then discover that while Apache or Nginx probably started up automatically, your Mongrels didn't, and your site has been down for the past 10 hours.

Here's a short list of some common Bad Things that can happen to daemons:

# Your hosting provider restarts your machine due to maintenance or malfunction.
# A daemon goes into a loop and becomes unresponsive, hogging memory and doing nothing.
# A daemon is waiting for a blocking process that never finishes, hogging memory and doing nothing.
# A daemon crashes due to a software bug.
# A daemon becomes unresponsive due to a hardware problem (eg: bad memory).

This list is theoretically endless, and the dangers to your application are very real. If you think you can just start Memcached and forget about it, you're (eventually) in for an unfortunate surprise.


h2. What Can You Do?

The standard solution, which is somewhat odd at first glance, is to use yet another daemon: a process monitor. You have to configure the monitor so it knows what processes you need to be running, how to check if they're running, and how to start them if they're not. You usually configure the monitor to check on your processes every 30-180 seconds.

When choosing a monitor, my requirements are fairly simple. A good monitor:

# *Must* start when your system boots up.
# *Must* be stable. Very stable. (You don't want to have to monitor your monitor, though on occasion this is necessary.)
# *Must* be lightweight so it doesn't take resources (memory or CPU cycles) from your important processes.

I haven't used a lot of monitors. In fact I've only used one. So, although I put some thought into my decision, take this recommendation for what it's worth: "Monit":http://mmonit.com/monit/. It's a mature (currently version 5), widespread piece of open source software for *NIX systems. You can install it on Ubuntu via:

{% highlight :bash %}
sudo apt-get install monit
{% endhighlight %}

A Monit configuration for Memcached might look like this (taken from "Memcached wiki":http://code.google.com/p/memcached/wiki/HowToMonitor):

{% highlight :bash %}
check process memcached with pidfile /var/run/memcached/memcached.pid
  group memcached
    start program = "/etc/init.d/memcached start"
    stop program = "/etc/init.d/memcached stop"
    if failed host 127.0.0.1 port 11211 then restart
{% endhighlight %}

Check your config file syntax with:

{% highlight :bash %}
sudo monit -t
{% endhighlight %}

and start Monit with:

{% highlight :bash %}
sudo monit
{% endhighlight %}

However, you'll also want to set the following in @/etc/default/monit@:

{% highlight :bash %}
startup=1
{% endhighlight %}

which will make Monit start when the system boots up. As stated before, *this is vital*.


h2. Am I An Atheist?

"God":http://god.rubyforge.org/ is a highly configurable process monitoring solution written in Ruby, configured in Ruby, and used on high volume sites like "GitHub":http://www.github.com/. As a Ruby programmer, why do I ignore God? While I can't comment from experience on whether God deserves its somewhat "negative reputation":http://stackoverflow.com/questions/768184/god-vs-monit, it fails my most basic criterion for a process monitor: it doesn't automatically and reliably start on system boot-up. Also, being a Ruby process, I have my doubts about its efficiency. (To utter another heresy: I love to write Ruby code, I don't always love to run it.)

Sure, I can "use rc.d":http://www.netbsd.org/docs/guide/en/chap-rc.html to launch God or any other monitor, but this involves some commands I can never remember, is a pain to test, and so is a process I'm less than comfortable with. I'd much rather my process monitor be "built-into" my operating system, or at least be as close as possible to this ideal (installed by the standard package manager is satisfactory). If I have to worry about the status of my process monitor, it's not serving its purpose. Basically, I'm willing to sacrifice a slick Ruby config file and some advanced monitoring options for some simplicity and peace of mind.

{% comment %}
rc.d for god:
http://mylescarrick.com/articles/simple_delayed_job_with_god
{% endcomment %}


h2. 
